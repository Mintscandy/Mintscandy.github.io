<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>文件操作</title>
    <link href="/2024/02/23/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <url>/2024/02/23/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>逻辑处理及循环</title>
    <link href="/2024/02/23/%E9%80%BB%E8%BE%91%E5%A4%84%E7%90%86%E5%8F%8A%E5%BE%AA%E7%8E%AF/"/>
    <url>/2024/02/23/%E9%80%BB%E8%BE%91%E5%A4%84%E7%90%86%E5%8F%8A%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>基本数据类型（详）</title>
    <link href="/2024/02/23/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E8%AF%A6%EF%BC%89/"/>
    <url>/2024/02/23/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E8%AF%A6%EF%BC%89/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>函数</title>
    <link href="/2024/02/23/%E5%87%BD%E6%95%B0/"/>
    <url>/2024/02/23/%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>变量和基本数据类型</title>
    <link href="/2024/02/23/%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2024/02/23/%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="变量和基本数据类型"><a href="#变量和基本数据类型" class="headerlink" title="变量和基本数据类型"></a>变量和基本数据类型</h1><h2 id="变量与内存"><a href="#变量与内存" class="headerlink" title="变量与内存"></a>变量与内存</h2><p><strong>在一个变量被赋值时，Python将会向内存申请一块内存空间来存放新的值，只要是赋值操作，产生新值都会新申请一块内存空间</strong>。那么我们要用一个变量，申请一个内存空间，这个问题不大，但是内存是有限的，我们不可能无限制申请，那我们申请的变量但是不用的变量，就要考虑释放内存，这个操作就是内存管理。内存管理是个很复杂的问题，但是Python为我们做了一个机制。</p><p><strong>::Python中还有“垃圾回收机制”，当一个内存，没有任何一个变量指向这个内存，那么它就会被回收::</strong></p><p><strong>只要申请新的内存空间其内存地址就会不同，id也会不同。</strong>::可以通过<code>id(变量名)</code>来查看变量的id::</p><p>::id值不等同于内存地址，但是id值是由内存地址转换（运算）来的::可以说 <strong>::id值是内存地址的映射::</strong></p><p>但是来看一个反例，我们来看一个代码👀</p><img src="/2024/02/23/%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/Image.png" class="" title="This is a picture"><p>是不是觉得被骗了，按理说，我们新赋值一个变量，我们的id就会改变，但是为什么a和b的id都是一样的，这就是<strong>小整数池</strong>的概念。</p><h2 id="小整数池"><a href="#小整数池" class="headerlink" title="小整数池"></a>小整数池</h2><p>首先，无论是<strong>往内存里放数据还是取数据，都是IO操作</strong>，计算机三大核心硬件（CPU，内存，硬盘）中，CPU的运行速度最快，内存其次，硬盘最慢；一旦你的程序里有了IO操作，那么就会拖慢CPU的运行速度，因此Python就做了一步优化，可以避免重复使用相同的值，而重复申请内存空间所带来的效率问题，Python解释器，会在启动的那一刻，创建出小整数池。<strong>其范围是-5～256</strong>，这些数字在使用时，不会申请新的内存空间，并且不会被 <strong>垃圾回收机制</strong> 回收。</p><p>我们可以来验证一下小整数池。</p><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><p>垃圾回收机制下有三个工作模块，<strong>引用计数机制，标记清除机制，分代回收机制</strong>。</p><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>当一个变量值被赋值给一个变量名时，那么这个变量值就会 引用计数+1，当我们使用<code>del 变量名</code> 清除了某一变量和对应值的绑定关系，或者同一个变量被赋予一个新值的时候，原变量绑定的值就会 引用计数-1 （这里还有其他变量和这个值绑定的情况）</p><p>我们来看一下上面的两种情况。由于一些代码编辑器会对Python优化，其得到的值就会不准确，这里我们使用Python编译器查看结果，在此之前，我们要使用一个包sys<strong>（使用<code>import sys</code>导入包)</strong></p><p>使用<code>sys.getrefcount(变量)</code> 来查看变量当前的引用计数，但是<strong>实际值是要-1</strong>的，包括了调用这个函数的临时计数。</p><p>因此“张xx”这个值将会被内存回收释放。</p><p>但是，垃圾回收机制只依靠引用计数是会产生问题的，因为有一些方法会欺骗到引用计数。</p><p>例如我们来看一个例子（循环引用）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br>l1 = [<span class="hljs-string">&#x27;你&#x27;</span>, <span class="hljs-string">&#x27;是&#x27;</span>]<br>l2 = [<span class="hljs-string">&#x27;是&#x27;</span>, <span class="hljs-string">&#x27;你&#x27;</span>]<br><span class="hljs-comment"># 接下来我们在l1的末尾，加上l2</span><br>l1.append(l2)<br><span class="hljs-built_in">print</span>(l1)  <span class="hljs-comment"># 内存中，2号索引放的就是l2的内存地址</span><br><span class="hljs-comment"># 在l2的末尾加上l1</span><br>l2.append(l1)<br><span class="hljs-built_in">print</span>(l2)  <span class="hljs-comment"># 内存中，2号索引放的就是l1的内存地址</span><br><span class="hljs-comment"># 上面这番操作后，我们的l1和l2就形成了你中有我，我中有你的关系</span><br><span class="hljs-comment"># 这两个列表存在相互引用的关系，这就是循环引用</span><br><span class="hljs-comment"># 我们来看它们的引用计数</span><br><span class="hljs-built_in">print</span>(sys.getrefcount(l1) - <span class="hljs-number">1</span>)  <span class="hljs-comment"># 2 一个是变量l1 一个是列表l2</span><br><span class="hljs-built_in">print</span>(sys.getrefcount(l2) - <span class="hljs-number">1</span>)  <span class="hljs-comment"># 2 一个是变量l2 一个是列表l1</span><br><span class="hljs-comment"># 引用计数都是2次，于是我们再做一个操作</span><br><span class="hljs-keyword">del</span> l1<br><span class="hljs-keyword">del</span> l2<br><span class="hljs-comment"># 我们将这两个变量捆绑的关系取消，也就是说明，我们再也无法通过l1，l2访问到这个两个列表了</span><br><span class="hljs-comment"># 它们的引用计数-1了，但是他们之间列表的相互引用还存在，这就会导致这片内存不会被 垃圾回收机制 回收</span><br></code></pre></td></tr></table></figure><p>所以只靠引用计数是不行的，我们继续了解 垃圾回收机制 的第二解决方案</p><h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p>在将标记清除之前，我们先来了解一下变量名在内存的存储方式，首先毫无疑问，变量名肯定也是存在内存里的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&#x27;张xx&#x27;</span><br></code></pre></td></tr></table></figure><p>我们来看它在内存中是怎么样的</p><p>可以看到，一个是栈区，专门用来存放变量名的，一个是堆区，专门用来存放变量值的，当我们赋值变量的时候，会在堆区开辟一片空间存放“张xx”，在栈区存放变量名name，两者形成引用关系，当堆区的变量被清除的时候，对应栈区的变量名也会被清除。</p><p>那么我们来看看循环引用在内存中的示意图</p><p>我用了红色的线表示间接引用，当我们执行<code>del l1</code> 的时候l1和内存地址0x0000001的绑定关系就解除了，执行<code>del l2</code> 也是相同的道理。我们无法通过任何变量访问到这两个内存空间，这时候这两块内存就泄露了。因而标记清除就出现了。</p><p>标记清除会在你内存空间不够用的时候，暂停程序，<strong>扫描栈区，不管是通过栈区能够直接引用或者间接引用到的，都标记为存活状态，一旦发现有栈区引用不到的值，都标记为死亡状态</strong>，只要我们一个变量无法使用直接引用引用到了，那么标记清除就会把它标记为垃圾，然后回收。</p><h4 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h4><p>由于引用计数在计数的时候，要将所有内存扫描一遍，这样的效率实在太低，我们来形象的说一下</p><p>我们刚开学的时候，老师肯定会检查作业，第一天，老师肯定会全部检查一遍，那些不做作业的同学，肯定就是垃圾了，然后我们每一次完成作业的，老师都标记🌸，比如当集齐5个🌸，就会被标记为良好的同学，这些同学检查作业的频次就会变成一个星期一次，又比如集齐10个🌸，就会被标记为优秀的同学，检查作业的频次就会变成一个月一次，这样看来，我们检查频次是在依次降低的。这样可以大大解决引用计数的效率问题。</p><h2 id="基础算术运算符"><a href="#基础算术运算符" class="headerlink" title="基础算术运算符"></a>基础算术运算符</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">Python中基础的算术运算符如下<br>a = <span class="hljs-number">13</span><br>b = <span class="hljs-number">3</span><br>c = a + b  <span class="hljs-comment"># 加</span><br>c = a - b  <span class="hljs-comment"># 减</span><br>c = a * b  <span class="hljs-comment"># 乘</span><br>c = a / b  <span class="hljs-comment"># 除法 得到一个浮点数</span><br>c = a // b  <span class="hljs-comment"># 除法 得到一个整数</span><br>c = a % b  <span class="hljs-comment"># 取余数</span><br>c = a ** b  <span class="hljs-comment"># 乘方</span><br></code></pre></td></tr></table></figure><h2 id="基础比较运算符"><a href="#基础比较运算符" class="headerlink" title="基础比较运算符"></a>基础比较运算符</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 比较运算符 == != &gt; &lt; &lt;= &gt;=</span><br><span class="hljs-comment"># 比较的结果是 True 和 False 其中的一个</span><br><span class="hljs-comment"># 注意 = 是赋值，== 才是表示等于</span><br><span class="hljs-comment"># 举个例子</span><br></code></pre></td></tr></table></figure><h3 id="基础逻辑运算符"><a href="#基础逻辑运算符" class="headerlink" title="基础逻辑运算符"></a>基础逻辑运算符</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 逻辑运算符 not and or</span><br><span class="hljs-comment"># 在程序中 会遇到很多很多的条件 到时候可能不只是一个条件可以解决的 所以就有了逻辑运算符</span><br><span class="hljs-comment"># not（非）and（与） or（或）</span><br><span class="hljs-comment"># 要记住这三个的优先级 是先not 然后是and 最后是or 可以记为NAO</span><br><span class="hljs-comment"># 我们前面不是说过么 True 是 1 False 是 0</span><br><span class="hljs-comment"># not的作用是逻辑取反</span><br><span class="hljs-built_in">print</span>(<span class="hljs-keyword">not</span> <span class="hljs-literal">True</span>)  <span class="hljs-comment"># False</span><br><br><span class="hljs-comment"># and的作用是 与 我们看一张表格吧😏（这个表格叫真值表）</span><br><span class="hljs-comment"># A     B</span><br><span class="hljs-comment"># 1 and 1 结果是 1</span><br><span class="hljs-comment"># 1 and 0 结果是 0</span><br><span class="hljs-comment"># 0 and 1 结果是 0</span><br><span class="hljs-comment"># 0 and 0 结果是 0</span><br><span class="hljs-comment"># 懂了么 只有当两个条件同时满足才会出 1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> <span class="hljs-literal">False</span>)  <span class="hljs-comment"># False</span><br><br><span class="hljs-comment"># or的作用是 或 我们还是来看真值表</span><br><span class="hljs-comment"># A     B</span><br><span class="hljs-comment"># 1 and 1 结果是 1</span><br><span class="hljs-comment"># 1 and 0 结果是 1</span><br><span class="hljs-comment"># 0 and 1 结果是 1</span><br><span class="hljs-comment"># 0 and 0 结果是 0</span><br><span class="hljs-comment"># 只要两个条件中的 其中一个 满足了 就可以出 1</span><br><span class="hljs-comment"># 是不是还是挺好理解的 🤩</span><br><span class="hljs-built_in">print</span>(<span class="hljs-literal">True</span> <span class="hljs-keyword">or</span> <span class="hljs-literal">False</span>)  <span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 赋值运算符 = += -= *= /= //= %= **=</span><br><span class="hljs-comment"># 其实你最先接触到的赋值符号就是 =</span><br><span class="hljs-comment"># 赋值运算符就是算术运算符加个等号 就可以了</span><br>a = <span class="hljs-number">11</span><br>a += <span class="hljs-number">1</span>  <span class="hljs-comment"># 等价于 a = a + 1</span><br><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># 12</span><br><span class="hljs-comment"># 那么其他的赋值运算符就是同理的 可以试试看</span><br></code></pre></td></tr></table></figure><hr><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><p>首先，在Python中，并没有所谓的数字类型，数字类型被分为了 <strong>整型（int）和 浮点型（float）</strong></p><p>整型和浮点型是可以做算术操作的，其<strong>操作的结果类型是 浮点型</strong></p><p>当然还可以做比较操作，结果就是 布尔类型的。</p><p>🤔这里有一个问题，有待考虑。就是在计算机中，都是使用二进制表示的，那么True就可以用1表示 False就可以用0表示就是“非黑即白，不是True就是False”，以也有人认为<strong>布尔类型</strong>也应该被归类到<strong>数字类型</strong>中。</p><hr><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p>字符串可以使用单引号，双引号，三引号这都是可以的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 字符串类型</span><br>a = <span class="hljs-string">&#x27;Python&#x27;</span><br>b = <span class="hljs-string">&quot;Python&quot;</span><br>c = <span class="hljs-string">&quot;&quot;&quot;Python&quot;&quot;&quot;</span> <span class="hljs-comment"># 这里的三引号并不是注释，当三引号的被给了一个变量，这个就会变成一个字符串</span><br></code></pre></td></tr></table></figure><p>那么，如果我们有一个需求，我们要打出“一起‘玩’Python”那么如果我们这样打</p><p>就出现了红色波浪线，这是因为，引号是成对出现的，那么那个“玩”所处的位置就很尴尬了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 我们可以这样做</span><br><span class="hljs-comment"># 在双引号内套上一个单引号，或者在单引号内套上双引号，这些都是被允许的</span><br><span class="hljs-comment"># 还有就是在引号前面加上\，表示转义，这样就可以正常显示了。</span><br>a = <span class="hljs-string">&quot;一起&#x27;玩&#x27;Python&quot;</span><br>a = <span class="hljs-string">&#x27;一起&quot;玩&quot;Python&#x27;</span><br>a = <span class="hljs-string">&#x27;一起\&#x27;玩\&#x27;Python&#x27;</span><br></code></pre></td></tr></table></figure><p>字符串是可以相加的，我们使用“+”可以将字符串连接起来。仅仅是字符串和字符串才能相加。字符串和数字是不能相加，但是可以相乘。举个例子，*** 相当于将字符串重复数次**。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-string">&#x27;人入&#x27;</span><br><span class="hljs-built_in">print</span>(a*<span class="hljs-number">5</span>) <span class="hljs-comment"># 人入人入人入人入人入</span><br></code></pre></td></tr></table></figure><hr><h2 id="列表类型"><a href="#列表类型" class="headerlink" title="列表类型"></a>列表类型</h2><p>前面的数字类型和字符串类型，都只能存一个值，但是如果我们的一个值想要包含多个信息，并且这些信息都可以被取到，那我们该使用什么类型呢？举个例子，比如我们想要保存一个人的爱好，应该使用字符串类型，就像下面这样</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">hobbies = <span class="hljs-string">&#x27;羽毛球，可乐，读书&#x27;</span><br></code></pre></td></tr></table></figure><p>这样也可以描述一个人的爱好，但是当我们想得到爱好的第二个值的时候，就没有办法了，这时候列表的概念就出现了，我们将这三个信息，放在一张表内，用索引和内容相互对应</p><table><thead><tr><th><strong>索引</strong></th><th><strong>内容</strong></th></tr></thead><tbody><tr><td>0</td><td>羽毛球</td></tr><tr><td>1</td><td>可乐</td></tr><tr><td>2</td><td>读书</td></tr></tbody></table><p>那比如我们想要拿到第二个爱好，是不是只要根据索引，就可以找到对应的值了，那么我们在Python中就要这样声明</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">hobbies = [<span class="hljs-string">&#x27;打羽毛球&#x27;</span>,<span class="hljs-string">&#x27;可乐&#x27;</span>,<span class="hljs-string">&#x27;读书&#x27;</span>]<br><span class="hljs-comment"># 如果想要得到第二个爱好只需要</span><br><span class="hljs-built_in">print</span>(hobbies[<span class="hljs-number">1</span>]) <span class="hljs-comment"># 可乐</span><br></code></pre></td></tr></table></figure><p><strong>注意，在Python中，索引的开始是0，我们想要调用列表，需要 变量名[索引] 得到内容</strong></p><p>列表内还可以存放其他的类型，我们可以在列表里放数字类型，字符类型，当然列表也是可以嵌套的</p><p>比如，我们要一个persons列表，存每个人的信息（包括姓名，年龄，爱好）那么我们该如何声明？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">persons = [[<span class="hljs-string">&#x27;张xx&#x27;</span>, <span class="hljs-number">23</span>, [<span class="hljs-string">&#x27;唱歌&#x27;</span>, <span class="hljs-string">&#x27;羽毛球&#x27;</span>, <span class="hljs-string">&#x27;篮球&#x27;</span>]], [<span class="hljs-string">&#x27;李xx&#x27;</span>, <span class="hljs-number">28</span>, [<span class="hljs-string">&#x27;打太极&#x27;</span>, <span class="hljs-string">&#x27;唱歌&#x27;</span>, <span class="hljs-string">&#x27;篮球&#x27;</span>]]]<br><span class="hljs-comment"># 实在不太会编名字</span><br><span class="hljs-comment"># 如果我们想要得到张xx的所有信息</span><br><span class="hljs-built_in">print</span>(persons[<span class="hljs-number">0</span>])  <span class="hljs-comment"># [&#x27;张xx&#x27;, 23, [&#x27;唱歌&#x27;, &#x27;羽毛球&#x27;, &#x27;篮球&#x27;]]</span><br><span class="hljs-comment"># 那比如我们想得到李xx的第二个爱好，我们应该</span><br><span class="hljs-built_in">print</span>(persons[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>][<span class="hljs-number">1</span>]) <span class="hljs-comment"># 唱歌</span><br><span class="hljs-comment"># 逐层嵌套，我们就用索引逐层去取</span><br></code></pre></td></tr></table></figure><p><strong>列表可以相当于其他编程语言中的 数组</strong></p><h2 id="字典类型"><a href="#字典类型" class="headerlink" title="字典类型"></a>字典类型</h2><p>列表类型只能通过 索引 去描述一个事物的位置。但如果我们要存张xx的身高，体重，薪水。那么虽然列表也可以存储，但是我们要去数索引，这是不是很麻烦。</p><p>于是我们引入 key对应值 这个key通常为字符串类型，这样就赋予了其有描述性功能。我们按照以下方式定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dic = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;张xx&#x27;</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">167</span>, <span class="hljs-string">&#x27;薪水&#x27;</span>: <span class="hljs-number">18000</span>&#125;<br></code></pre></td></tr></table></figure><p>我们定义了一个字典，其结构就像下面一样。</p><table><thead><tr><th><strong>key</strong></th><th><strong>值</strong></th></tr></thead><tbody><tr><td>name</td><td>张xx</td></tr><tr><td>height</td><td>167</td></tr><tr><td>薪水</td><td>18000</td></tr></tbody></table><p>我们要获取字典的值，就用 <strong>变量名[key]</strong>  去获取这个字典里某个key对应的值。</p><p>这个key也可以是数字类型的，那么我们的引用格式就是和列表一样了</p><p>同样字典里可以放列表，列表里也可以放字典。其取值方式也大同小异，遇到列表就索引取，遇到字典就key取。</p><h2 id="布尔类型和None"><a href="#布尔类型和None" class="headerlink" title="布尔类型和None"></a>布尔类型和None</h2><p>我们之前说过，布尔类型在内存中被表示的时候，是采用了0或者1来表示的，因此我们的布尔类型也有人将其归类到数字类型，只有两个值0和1，True就是1，False就是0。并且它们是被当作0和1来处理的，True+1的结果就是2</p><p>None属于nonetype类型，是nonetype数据类型的唯一值</p><p>所有<strong>有值的变量</strong>，不管是数字，字符串，列表，还是字典，<strong>直接用于判断的时候，除了0和None都会被认作为True</strong></p><p><strong>0、None、空字符串、空列表、空字典都是False</strong></p><h2 id="直接引用和间接引用"><a href="#直接引用和间接引用" class="headerlink" title="直接引用和间接引用"></a>直接引用和间接引用</h2><p>我们来看一段代码，我们在一个列表里，引用一个变量</p><p>在列表info里的变量是间接引用，我们也可以用info[0]访问到name这个变量，但是这时候是间接引用，我们如何证明这两个变量是同一个呢？很简单，看看id是不是同一个就可以了。</p><p>说明我们访问的值是同一个，info[0]和name都指向了同一片内存空间。这就是间接引用和直接引用</p><h2 id="列表在内存中的存储方式"><a href="#列表在内存中的存储方式" class="headerlink" title="列表在内存中的存储方式"></a>列表在内存中的存储方式</h2><p>我们来看一个列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">info = [<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>]<br></code></pre></td></tr></table></figure><p>我画了一张图来说明这个列表在内存中的存储方式</p><p>首先，我们的列表在内存中开辟一片空间，空间内0号索引位存放着“a”的内存地址，这个内存地址肯定指向的是“a”，然后这一整个列表和info这个变量所绑定。</p><p>因此，字典在内存的存储方式也类似，只是把索引变成了key。</p><h4 id="一个问题🤔-在如下代码的情况下，我们print-info-0-的结果是什么？"><a href="#一个问题🤔-在如下代码的情况下，我们print-info-0-的结果是什么？" class="headerlink" title="一个问题🤔 在如下代码的情况下，我们print(info[0])的结果是什么？"></a>一个问题🤔 在如下代码的情况下，我们print(info[0])的结果是什么？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">张xx<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs other">李xx<br></code></pre></td></tr></table></figure><p>没错，答案仍然是“张xx”</p><p><strong>分析：</strong>我们来看这个列表在内存的存放方式</p><p>在代码还没执行到 <code>name=‘李xx‘</code> 的时候，我们“张xx”的引用计数就是2，当代码执行到 <code>name=’李xx‘</code>  的时候，我们name被重新指向了一个新的值，此时我们info内0索引位还存着原来“张xx”的内存地址，这个变量的引用计数就还是1，所以不会被<strong>垃圾回收机制</strong>回收。我们也没有在info的列表里修改其对应关系，所以 info[0] 指向的仍然还是“张xx”而不是“李xx”。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>我们学过int类型，float类型，str类型，list类型，dict类型，我们都可以使用类型名(变量)，来实现类型转换，例如<code>int(‘221’)</code> 就是将字符串类型的221转成整型的221。当然其他类型转换也是大同小异。这里不详细展开了。</p><h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Python的进制转换方法</span><br><span class="hljs-comment"># 十进制转二进制</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bin</span>(<span class="hljs-number">222</span>))  <span class="hljs-comment"># 0b11011110</span><br><span class="hljs-comment"># 十进制转八进制</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">oct</span>(<span class="hljs-number">222</span>))  <span class="hljs-comment"># 0o336</span><br><span class="hljs-comment"># 十进制转十六进制</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(<span class="hljs-number">222</span>))  <span class="hljs-comment"># 0xde</span><br><br><span class="hljs-comment"># 二进制转十进制(传入第二个参数，说明我们传入的是二进制)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;0b11011110&#x27;</span>, <span class="hljs-number">2</span>))  <span class="hljs-comment"># 222</span><br><span class="hljs-comment"># 二进制转八进制(传入第二个参数，说明我们传入的是八进制)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;0o336&#x27;</span>, <span class="hljs-number">8</span>)) <span class="hljs-comment"># 222</span><br><span class="hljs-comment"># 二进制转十六进制(传入第二个参数，说明我们传入的是十六进制)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;0xde&#x27;</span>, <span class="hljs-number">16</span>))  <span class="hljs-comment"># 222</span><br></code></pre></td></tr></table></figure><p>懂得进制转换就行了，这只是一种方式。</p><p>至此Python变量和基本数据类型就讲完了，后面还有一份“[[基本数据类型（详）]]基本数据类型（详）”讲关于这些数据类型的操作。<strong>要着重理解变量在内存中的存储方式，这会对你对计算机的底层理解更加深刻。</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/02/23/Temp/Hexo/"/>
    <url>/2024/02/23/Temp/Hexo/</url>
    
    <content type="html"><![CDATA[<p>a</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>功能测试</title>
    <link href="/2024/02/23/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    <url>/2024/02/23/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="功能测试用例"><a href="#功能测试用例" class="headerlink" title="功能测试用例"></a>功能测试用例</h1><p><strong>直接测试项目</strong><br>UI测试，首页按钮功能测试，排序，列表显示。<br><strong>可以直接复制粘贴</strong><br>资产类别&#x2F;品牌&#x2F;取得方式（新增、修改、启用、禁用）<br>⬆️资产管理员只需要（UI测试、排序、显示、首页按钮功能测试）<br><strong>需要修改部分条件</strong><br>资产入库、资产借还、资产转移、资产维修（需要稍微修改一下部分条件）<br><strong>需要查询测试</strong><br>超级管理员：供应商、存放地点<br>资产管理员：供应商、存放地点、人员管理、资产入库、资产借还、资产转移、资产维修、资产报废、资产盘点、资产申购<br><strong>需要翻页测试</strong><br>人员管理、资产借还、资产入库、资产转移、资产维修、资产报废<br>（记录大于10条要翻页）<br>翻页测试用例：</p><ol><li>列表页数据小于10条；查看翻页功能；不显示翻页</li><li>列表页数据大于10条；查看翻页功能；显示翻页功能，首页，页码，末页，&gt;，&lt;</li><li>大于10条；当前为第一页；首页无法点击，当前页码高亮显示</li><li>大于10条；当前为最后一页；末页无法点击，当前页码高亮显示</li><li>大于10条；当前不为第一页，点击&lt;；跳转到对应页面，页码高亮显示</li><li>大于10条；当前不为第一页，点击&gt;；跳转到对应页面，页码高亮显示</li><li>大于10条；当前不为首页，点击“首页”；跳转到对应首页，页码高亮显示</li><li>大于10条；当前不为末页，点击“末页”；跳转到对应末页，页码高亮显示</li><li>大于10条；点击页码；跳转到对应页面，页码高亮显示</li><li>大于10条；输入查询条件，点击翻页；翻页功能正常，查询条件保留</li></ol><p><strong>查看***详情</strong><br>供应商、存放地点<br>资产借还（查看借用单详情）<br>资产转移（查看转移单详情）<br>资产申购（查看申购单详情）</p>]]></content>
    
    
    <categories>
      
      <category>软测</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>弹性盒布局</title>
    <link href="/2024/02/23/%E5%BC%B9%E6%80%A7%E7%9B%92%E5%B8%83%E5%B1%80/"/>
    <url>/2024/02/23/%E5%BC%B9%E6%80%A7%E7%9B%92%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="弹性盒布局"><a href="#弹性盒布局" class="headerlink" title="弹性盒布局"></a>弹性盒布局</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>弹性盒布局又叫做 Flexible Box，通常被叫做为 flexbox，是一种一维的布局模型。<br>flexbox 是一种一维的布局，是因为一个 flexbox 一次只能处理一个维度上的元素布局，一行或者一列。作为对比的是另外一个二维布局  CSS Grid Layout，可以同时处理行和列上的布局。</p><h2 id="FlexBox-的两根轴线"><a href="#FlexBox-的两根轴线" class="headerlink" title="FlexBox 的两根轴线"></a>FlexBox 的两根轴线</h2><p>首先在 flex 布局中，我们有两根轴线——主轴和交叉轴，主轴是通过使用 flex-direction 定义的，另一根轴垂直于它。</p><h3 id="主轴"><a href="#主轴" class="headerlink" title="主轴"></a>主轴</h3><p>主轴取值有如下四个</p><ul><li><code>row</code></li><li><code>row-reverse</code></li><li><code>column</code></li><li><code>column-reverse</code><br>  如果是 <code>row</code> 或者 <code>row-reverse</code> 的时候，主轴将会沿着 inline 的方向延伸。<br>  如果是 <code>column</code> 或者 <code>column-reverse</code>的时候，主轴将会以上下方向延伸，也就是 block 排列的方向。</li></ul><h3 id="交叉轴"><a href="#交叉轴" class="headerlink" title="交叉轴"></a>交叉轴</h3><p>交叉轴是垂直于主轴的，flexbox 的特性是沿着主轴或者交叉轴对齐之中的元素。</p><h2 id="起始线和终止线"><a href="#起始线和终止线" class="headerlink" title="起始线和终止线"></a>起始线和终止线</h2><p>在过去 CSS 的书写模式主要被认为是水平的，从左到右。现代的布局方式涵盖了书写模式的范围，因为有些国家是从右往左书写的，<br>如果 <code>flex-direction</code> 是 <code>row</code> ，并且在书写英文的情况下，那么主轴的起始线是左边，终止线是右边。<br>如果书写阿拉伯文，则主轴的起始线为右边，终止线为左边。<br><br>在这两种情况下，交叉轴的起始线是 flex 容器的顶部，终止线是底部，因为这两种语言都是水平书写模式。</p><h2 id="Flex-容器"><a href="#Flex-容器" class="headerlink" title="Flex 容器"></a>Flex 容器</h2><p>文档中采用了 flexbox 的区域被称为 flex 容器。将容器的<code>display</code>属性改为<code>flex</code>或者<code>inline-flex</code>即可。默认的 flex 容器有如下属性。</p><ul><li>元素排列为一行，因为 flex-direction 属性初始值为 row。</li><li>元素从主轴的起始线开始。</li><li>元素不会在主维度方向拉伸，但是可以缩小。  <img src="/2024/02/23/%E5%BC%B9%E6%80%A7%E7%9B%92%E5%B8%83%E5%B1%80/%E5%BC%B9%E6%80%A7%E7%9B%92%E5%B8%83%E5%B1%80-20240106143416555.png" class="" title="这是一张图片">  我们可以看上图，在上图中我们设置<code>container</code>的宽度为 800px，而子元素的宽度为 100px，可以看到并没有被拉伸。</li><li>元素会被拉伸来填充交叉轴的大小。</li><li><code>flex-basis</code>的属性为<code>auto</code> 。</li><li><code>flex-wrap</code> 属性为<code>nowrap</code> 。</li></ul><p>会让元素呈线性排列，并且将自己的大小作为主轴大小，如果元素超出容器，他将会溢出而不会换行。如果一些元素的高度比其他的元素高，则元素会沿交叉轴被拉伸来填满大小。</p><h2 id="用-flex-wrap-实现多行-Flex-容器"><a href="#用-flex-wrap-实现多行-Flex-容器" class="headerlink" title="用 flex-wrap 实现多行 Flex 容器"></a>用 flex-wrap 实现多行 Flex 容器</h2><p>虽然<code>flexbox</code>为一维模型，但我们可以使 flex 应用到多行，在这样做的时候，应该将每一行看作为一个新的<strong>flex 容器</strong>。任何空间分布都将会在该行上发生，而不影响改空间分布的其他行。<br><br>我们需要为<code>flex-wrap</code>属性添加一个属性值<code>wrap</code>。<br>设置完成后，这样你就会因为元素太多太大，而无法全部显示在一行，则会换行显示。当盒子的宽度<strong>不足以放下一个完整子元素</strong>的时候，将会换行。</p><h2 id="简写属性"><a href="#简写属性" class="headerlink" title="简写属性"></a>简写属性</h2><p>当然也可以将<code>flex-direction</code>和<code>flex-wrap</code>组合简写为一个属性<code>flex-flow</code> 第一个值为<code>flex-direction</code> 第二个值为 <code>flex-wrap</code></p><h2 id="flex-元素上的属性"><a href="#flex-元素上的属性" class="headerlink" title="flex 元素上的属性"></a>flex 元素上的属性</h2><p>为了更好的控制 flex 元素，有三个属性可以作用于他们：</p><ul><li><code>flex-grow</code></li><li>&#96;felx-shrink</li><li>&#96;flex-basis</li></ul><p>在此之前，我们需要了解<strong>可用空间</strong>这个概念，这些概念其实就是改变了 flex 容器中可用空间的行为。<br>假设，在 1 个 500px 的容器中，我们有 3 个 100px 宽的元素，那么这 3 个元素需要占用 300px 的宽，剩下的 200px 的可用空间。在默认情况下，flexbox 将会把这 200px 的空间留在最后一个元素的后面。<br><br>如果期望这些元素能够自动地扩展去填充满剩下的空间，那我们需要去控制可用空间在这几个元素之间如何分配，这就是元素上 flex 属性需要做的事情。</p><h2 id="Flex-元素属性：flex-basis"><a href="#Flex-元素属性：flex-basis" class="headerlink" title="Flex 元素属性：flex-basis"></a>Flex 元素属性：<code>flex-basis</code></h2><p><code>flex-basis</code>  定义了该元素的<strong>空间大小</strong>（<strong>the size of that item in terms of the space</strong>），flex 容器里除了元素所占的空间以外的富余空间就是<strong>可用空间</strong> available space。该属性的默认值是  <code>auto</code> 。此时，浏览器会检测这个元素是否具有确定的尺寸。在上面的例子中，所有元素都设定了宽度（width）为 100px，所以  <code>flex-basis</code>  的值为 100px。(也就是会自动覆盖 width)<br>如果没有给元素设定尺寸，<code>flex-basis</code>  的值采用元素内容的尺寸。这就解释了：我们给只要给 Flex 元素的父元素声明  <code>display: flex</code> ，所有子元素就会排成一行，且自动分配小大以充分展示元素的内容。</p><h2 id="Flex-元素：-flex-grow"><a href="#Flex-元素：-flex-grow" class="headerlink" title="Flex 元素：&#96;flex-grow"></a>Flex 元素：&#96;flex-grow</h2><p>可以简单理解为 Android 开发中 <code>layout_weight</code> 一致。<br><br><code>flex-grow</code>  若被赋值为一个正整数，flex 元素会以  <code>flex-basis</code>  为基础，沿<strong>主轴方向增长</strong>尺寸。这会使该元素延展，并占据此方向轴上的可用空间（available space）。如果有其他元素也被允许延展，那么他们会各自占据可用空间的一部分。</p><p>如果我们给上例中的所有元素设定  <code>flex-grow</code>  值为 1，容器中的可用空间会被这些元素<strong>平分</strong>。它们会延展以填满容器主轴方向上的空间。</p><p>flex-grow 属性可以按比例分配空间。如果第一个元素  <code>flex-grow</code>  值为 2，其他元素值为 1，则第一个元素将占有 2&#x2F;4（上例中，即为 200px 中的 100px）, 另外两个元素各占有 1&#x2F;4（各 50px）。</p><h2 id="Flex-元素：flex-shrink"><a href="#Flex-元素：flex-shrink" class="headerlink" title="Flex 元素：flex-shrink"></a>Flex 元素：<code>flex-shrink</code></h2><p>会以 <code>flex-basis</code> 为基础，沿着主轴方向收缩尺寸。会使得该元素收缩。<br>如果设置不同的容器大小，则会按照比例均分<code>flex-basis</code>。</p><p><code>flex-grow</code>属性是处理 flex 元素在主轴上增加空间的问题，相反<code>flex-shrink</code>属性是处理 flex 元素收缩的问题。如果我们的容器中没有足够排列 flex 元素的空间，那么可以把 flex 元素<code>flex-shrink</code>属性设置为正整数来缩小它所占空间到<code>flex-basis</code>以下。与<code>flex-grow</code>属性一样，可以赋予不同的值来控制 flex 元素收缩的程度——给<code>flex-shrink</code>属性赋予更大的数值可以比赋予小数值的同级元素收缩程度更大。</p><h2 id="元素之间的对齐和空间分配"><a href="#元素之间的对齐和空间分配" class="headerlink" title="元素之间的对齐和空间分配"></a>元素之间的对齐和空间分配</h2><p>FlexBox 的一个关键特性是能够设置 flex 元素沿主轴方向和交叉轴方向的对齐方式，以及他们之间的空间分配。</p><p><code>align-items</code><br>这个属性的初始值为 stretch，这就是为什么 flex 元素会默认被拉伸到最高元素的高度，实际上他们是被拉伸填满 flex 容器——最高的元素定义了容器的高度。它可以是如下值</p><ul><li><code>stretch</code> 默认值</li><li><code>flex-start</code> 使得 flex 元素按照 flex 容器的顶部对齐</li><li><code>flex-end</code> 使它们按 flex 容器的下部对齐</li><li><code>center</code> 是他们居中对齐</li></ul><p><code>justify-content</code><br>这个属性的初始值为 <code>flex-start</code> 元素从容器的起始线排列，设置为 <code>flex-end</code> 从终止线开始排列。或者选择 <code>center</code> ，在中间排列。<br>也可以将值设置为<code>space-between</code> ，将元素排列好后的剩余空间拿出来，平均分配到元素之间，使得元素之间的间隔相等。或者使用<code>space-around</code> 使得每个元素的左右空间相等。</p><ul><li><code>flex-grow</code>：该元素获得（伸张）多少正可用空间（positive free space）？</li><li><code>flex-shrink</code>：该元素要消除（收缩）多少负可用空间（negative free space）？</li><li><code>flex-basis</code>：在该元素未伸张和收缩之前，它的大小是多少？</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/02/23/hello-world/"/>
    <url>/2024/02/23/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
